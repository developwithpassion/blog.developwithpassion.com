---
layout: post
title: "How I'm Currently Writing My BDD Style Tests - Part 2"
comments: true
date: 2008-12-22 09:00
categories:
- c sharp
- programming
---

We left off in [part 1](http://blog.developwithpassion.com/HowIrsquomCurrentlyWritingMyBDDStyleTestsNdashPart1.aspx) with an example of a test written using my current style and I finished off outlining the skeleton for one of the base classes that shields the actual Concern classes from a lot of noisy test related nomenclature.  
In this post I am going to break down the responsibilities of the “an_observations_basic_set_of_behaviours” class. For a quick reminder, here is the skeleton outline of the class:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> [<span style="color: #2b91af">Observations</span>]    <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">abstract</span> <span style="color: blue">class</span> <span style="color: #2b91af">an_observations_set_of_basic_behaviours</span>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">protected</span> <span style="color: #2b91af">IDictionary</span><<span style="color: #2b91af">Type</span>, <span style="color: blue">object</span>> dependencies;    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: #2b91af">Exception</span> exception_thrown_while_the_sut_performed_its_work;    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">protected</span> <span style="color: #2b91af">Action</span> behaviour_of_the_sut;    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: #2b91af">SetUp</span>]    <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">void</span> setup() {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">void</span> prepare_to_make_an_observation() {}    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: #2b91af">TearDown</span>]    <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">void</span> tear_down() {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">after_all_observations</span> a = () => dependencies.Clear();    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">ICommand</span> build_command_chain<DelegateType>() {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">void</span> run_action<DelegateType>() {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">protected</span> <span style="color: blue">virtual</span> <span style="color: blue">void</span> initialize_the_sut() {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">public</span> <span style="color: blue">void</span> doing(<span style="color: #2b91af">Action</span> action) {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">protected</span> <span style="color: #2b91af">Exception</span> exception_thrown_by_the_sut    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">get</span> { }    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: #2b91af">Exception</span> get_exception_throw_by(<span style="color: #2b91af">Action</span> action) {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">protected</span> <span style="color: blue">object</span> an(<span style="color: #2b91af">Type</span> type) {}    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">protected</span> InterfaceType an<InterfaceType>() <span style="color: blue">where</span> InterfaceType : <span style="color: blue">class</span> {}    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
Let’s start off by discussing the fields:  <p style="font-size: 12pt; background: white; margin: 0px; color: black; font-family: verdana"><span style="color: blue">static</span> <span style="color: blue">protected</span> <span style="color: #2b91af">IDictionary</span><<span style="color: #2b91af">Type</span>, <span style="color: blue">object</span>> dependencies;  <p style="font-size: 12pt; background: white; margin: 0px; color: black; font-family: verdana">  <div style="font-size: 12pt; background: white; color: black; font-family: verdana">   <ul>     <li>       
This field is hopefully pretty self explanatory. It is a dictionary that will contain any direct dependencies of the SUT. In most of my apps I tend to favour Constructor based DI so, this dictionary basically contains the set of objects (mocks and/or reals) that the sut will depend on. How this gets populated will be discussed later.     </li>   </ul> </div>  <div style="font-size: 12pt; background: white; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">static</span> <span style="color: #2b91af">Exception</span> exception_thrown_while_the_sut_performed_its_work; </div>  <ul>   <li><font face="Verdana" size="3">This field will be used to store a reference to the exception that the sut threw while it performed its work. Is used in conjunction with the doing() method (more on that later).</font> </li> </ul>  <div style="font-size: 12pt; background: white; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">static</span> <span style="color: blue">protected</span> <span style="color: #2b91af">Action</span> behaviour_of_the_sut; </div>  <ul>   <li><font face="Verdana" size="3">I am going to revisit this field when we discuss the doing() method</font> </li> </ul>  
<font face="Verdana" size="3"></font>  
  
That takes care of the first set of fields, lets move on to a method that should look very familiar to MbUnit/NUnit people:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> [<span style="color: #2b91af">SetUp</span>]    <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">void</span> setup()    <p style="margin: 0px"> {    <p style="margin: 0px"> exception_thrown_while_the_sut_performed_its_work = <span style="color: blue">null</span>;    <p style="margin: 0px"> dependencies = <span style="color: blue">new</span> <span style="color: #2b91af">Dictionary</span><<span style="color: #2b91af">Type</span>, <span style="color: blue">object</span>>();    <p style="margin: 0px"> prepare_to_make_an_observation();    <p style="margin: 0px"> } </div>  
  
This is a traditional MbUnit setup method. Because it is decorated with the SetUp attribute, all of the code in this method will get run once before each observation (test). Essentially this method is used to reset stateful fields, this is not that interesting. The guts of setup happen in the following method:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: blue">void</span> prepare_to_make_an_observationjjj()    <p style="margin: 0px"> {    <p style="margin: 0px"> run_action<<span style="color: #2b91af">context</span>>();    <p style="margin: 0px"> initialize_the_sut();    <p style="margin: 0px"> run_action<<span style="color: #2b91af">after_the_sut_has_been_initialized</span>>();    <p style="margin: 0px"> run_action<<span style="color: #2b91af">because</span>>();    <p style="margin: 0px"> } </div>  
In this base class the initialize_the_sut method has an empty implementation. The prepare_to_make_an_observation method leverages a hook method (initialize_the_sut) that can be leveraged (it will be by an_observation_for_an_instance_sut). In the base class, it is a virtual method with no implementation. As you can see, this method is responsibility for performing the following actions before an observation can be made:  <ul>   <li>Establishing the context (run_action<context>()) </li>    <li>Initializing the SUT </li>    <li>Invoking the behaviour under test (run_action<because>()) </li> </ul>  
Again this is a small little method that basically serves as a driver for prepping the way to be able to make observations. By the time we actually enter an observation in our actual fixtures, the SUT has already performed its work!!  
Now I am sure you are wondering what the deal is with the run_action method? Here is the signature for the run_action method:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">void</span> run_action<DelegateType>() </div>  
This method is a generic method that accepts a delegate type as its generic argument. Again this is a convention that is understood by the naming of the generic parameter. You can’t place constraints on a generic method that constrain the Generic argument to be assignable from a delegate (of course, you can do this with a guard clause). Here are the different delegate signatures that I defined for use in the test-harnesses:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">delegate</span> <span style="color: blue">void</span> <span style="color: #2b91af">context</span>(); </div>  
  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">delegate</span> <span style="color: blue">void</span> <span style="color: #2b91af">after_the_sut_has_been_initialized</span>(); </div>  
  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">delegate</span> <span style="color: blue">void</span> <span style="color: #2b91af">because</span>(); </div>  
  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">delegate</span> <span style="color: blue">void</span> <span style="color: #2b91af">after_each_observation</span>(); </div>  
  
You may be wondering why I did not just use the plain old action delegate as opposed to creating discrete delegate types. This is so the driver class (this one we are examining) has a clearer way of differentiation between the different delegates. Without the named delegate types, I would have to resort to following a convention for the name I assigned to a field for an Action delegate (messy, messy).  
Here is the full implementation of the run_action method:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: blue">void</span> run_action<DelegateType>()    <p style="margin: 0px"> {    <p style="margin: 0px"> build_command_chain<DelegateType>().run();    <p style="margin: 0px"> }    <p style="margin: 0px"> </div>  
  
Once again, this method is pretty simple as it is really delegating its responsibility to whatever gets created by the build_command_chain method. So lets dive into the full body of this method, as this is really where the majority of the work is being done:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: #2b91af">ICommand</span> build_command_chain<DelegateType>()    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">var</span> actions = <span style="color: blue">new</span> <span style="color: #2b91af">Stack</span><<span style="color: #2b91af">ICommand</span>>();    <p style="margin: 0px"> <span style="color: blue">var</span> current_class = GetType();    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">while</span> (current_class.is_a_concern_type())    <p style="margin: 0px"> {    <p style="margin: 0px"> actions.Push(<span style="color: blue">new</span> <span style="color: #2b91af">DelegateFieldInvocation</span>(<span style="color: blue">typeof</span> (DelegateType), <span style="color: blue">this</span>, current_class));    <p style="margin: 0px"> current_class = current_class.BaseType;    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">return</span> actions.as_command_chain();    <p style="margin: 0px"> } </div>  
  
So what is going on here. Take a look at this test one more time as it will give you a good visual as to what is going on:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> [<span style="color: #2b91af">Concern</span>(<span style="color: blue">typeof</span> (<span style="color: #2b91af">MappingStep</span><,,>))]    <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">when_an_expression_mapping_step_is_told_to_run</span> :    <p style="margin: 0px"> <span style="color: #2b91af">concern_for_mapping_step</span>    <p style="margin: 0px">    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: #2b91af">SomeSourceObject</span> item;    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: #2b91af">SomeDestinationObject</span> destination;    <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">string</span> name;    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">context</span> c = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> item = <span style="color: blue">new</span> <span style="color: #2b91af">SomeSourceObject</span>();    <p style="margin: 0px"> name = <span style="color: #a31515">"JP"</span>;    <p style="margin: 0px"> destination = <span style="color: blue">new</span> <span style="color: #2b91af">SomeDestinationObject</span>();    <p style="margin: 0px">    <p style="margin: 0px"> source_evaluator.Stub(x => x.evaluate_against(item)).Return(name);    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">because</span> b = () => sut.map(item, destination);    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: #2b91af">Observation</span>]    <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">void</span> should_run_the_target_evaluator_passing_it_the_information_retrieved_from_evaluating_the_source()    <p style="margin: 0px"> {    <p style="margin: 0px"> target_action.was_told_to(x => x.act_against(destination, name));    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
I chose not to also put in this Concerns base class, the only important thing to remember about the “concern_for_mapping_step” is that it also has its own context block :  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: #2b91af">context</span> c = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> target_action = the_dependency<<span style="color: #2b91af">ITargetAction</span><<span style="color: #2b91af">SomeDestinationObject</span>, <span style="color: blue">string</span>>>();    <p style="margin: 0px"> source_evaluator = the_dependency<<span style="color: #2b91af">ISourceEvaluator</span><<span style="color: #2b91af">SomeSourceObject</span>, <span style="color: blue">string</span>>>();    <p style="margin: 0px"> }; </div>  
  
  
It is important to remember that the “an_observations_basic_set_of_behaviours” class is the test driver. Here is the inheritance hierarchy for this current test fixture:  <ul>   <li>an_observations_basic_set_of_behaviours      <ul>       <li>observations_for_an_instance_sut          <ul>           <li>obsevations_for_a_sut_with_a_contract              <ul>               <li>concern_for_mapping_step                  <ul>                   <li>when_an_expression_mapping_step_is_told_to_run </li>                 </ul>               </li>             </ul>           </li>         </ul>       </li>     </ul>   </li> </ul>  
At any point in the chain (starting from the top, working down) each level could have its own context to run. The run_action method is responsible for walking the inheritance hierarchy of a particular concern and building a chain of “commands” for a particular delegate type. Once the command chain has been build, the chain can be executed in the right order (from top to bottom) to ensure that any prior context in a base class has been established before a subclass runs. If you are already thinking, could he not have done the same thing with abstract/virtual methods. Yes. When I initially started down that route, I kept getting stung by forgetting to call back into the base method. By now having to worry about calling the base method prior to doing your own work, you as a developer can just focus on the context that is applicable to a particular test. You can do this, as the driver class is responsible for ensuring blocks run in the order they are supposed to run. Without the driver class, all the fields that have lambdas assigned to them would be useless as they are just sitting there waiting to be invoked.  
At the end of the while loop in the build_command_chain method there will be a stack (I chose stack as it is a LIFO structure, which is perfect for walking a class hierarchy, as when the last item is added – the base class, I can just start popping items off and they will be in the right order, ending with the ultimate test class itself). The stack itself is being used to store a set of ICommand implementations. Here is the ICommand interface:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">interface</span> <span style="color: #2b91af">ICommand</span>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">void</span> run();    <p style="margin: 0px"> } </div>  
  
This is a pretty stock interface that I have used for years. The uses are endless!! How does the loop know when to end? What is with the following method?:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px">current_class.is_a_concern_type() </div>  
  
The field current_class is of type Type. The is_a_concern_type method is a local extension method that has the following implementation:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: blue">static</span> <span style="color: blue">public</span> <span style="color: blue">bool</span> is_a_concern_type(<span style="color: blue">this</span> <span style="color: #2b91af">Type</span> type)    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">return</span> <span style="color: blue">typeof</span> (<span style="color: #2b91af">an_observations_set_of_basic_behaviours</span>)    <p style="margin: 0px"> .IsAssignableFrom(type);    <p style="margin: 0px"> } </div>  
  
This method just adds a bit of readability (from the point of usage, which is a huge bonus of extension methods) and ensures that we wont worry about putting anything that is not either a derivative of an_observations_set_of_basic_behaviours or the an_observations_set_of_basic_behaviours type itself on the stack (it will always be the top item on the stack at the end of the traversal).  
So lets explore the line that does the grunt work:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px">actions.Push(<span style="color: blue">new</span> <span style="color: #2b91af">DelegateFieldInvocation</span>(<span style="color: blue">typeof</span> (DelegateType), <span style="color: blue">this</span>, current_class)); </div>  
  
Keep in mind that the actions field is a stack of ICommand. It stands to reason that the DelegateFieldInvocation class is an ICommand implementation. Which it is. The DelegateFieldInvocation class takes in its constuctor a delegate type to scour for, an instance to act against (always this), and finally the particular type to reflect against (this will change as we continue to walk up the inheritance hierarchy). Here is the implementation of the DelegateFieldInvocation:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">DelegateFieldInvocation</span> : <span style="color: #2b91af">ICommand</span>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">const</span> <span style="color: #2b91af">BindingFlags</span> probing_flags = <span style="color: #2b91af">BindingFlags</span>.Static | <span style="color: #2b91af">BindingFlags</span>.NonPublic | <span style="color: #2b91af">BindingFlags</span>.Public | <span style="color: #2b91af">BindingFlags</span>.DeclaredOnly;    <p style="margin: 0px"> <span style="color: #2b91af">Type</span> delegate_type;    <p style="margin: 0px"> <span style="color: blue">readonly</span> <span style="color: blue">object</span> instance;    <p style="margin: 0px"> <span style="color: #2b91af">IEnumerable</span><<span style="color: #2b91af">FieldInfo</span>> fields;    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">public</span> DelegateFieldInvocation(<span style="color: #2b91af">Type</span> delegate_type, <span style="color: blue">object</span> instance, <span style="color: #2b91af">Type</span> current_type)    <p style="margin: 0px"> {    <p style="margin: 0px"> fields = current_type.GetFields(probing_flags);    <p style="margin: 0px"> <span style="color: blue">this</span>.delegate_type = delegate_type;    <p style="margin: 0px"> <span style="color: blue">this</span>.instance = instance;    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: blue">public</span> <span style="color: blue">void</span> run()    <p style="margin: 0px"> {    <p style="margin: 0px"> all_fields_of_the_target_delegate_type().each(x => x.GetValue(instance).downcast_to<<span style="color: #2b91af">Delegate</span>>().DynamicInvoke());    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">IEnumerable</span><<span style="color: #2b91af">FieldInfo</span>> all_fields_of_the_target_delegate_type()    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: blue">return</span> fields.Where(x => x.FieldType.Equals(delegate_type));    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
  
All this command does in its run implementation is scour all of the fields in the “current_type” and filters them to look for only fields of the certain delegate type being searched for. Once the particular delegate type is found, we get the value of the field using the instance:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px">x.GetValue(instance).downcast_to<<span style="color: #2b91af">Delegate</span>>() </div>  
downcast_to is just a utility extension method to do casting. At this point we have an actual reference to the delegate. With that, because we know (again by convention) that all of the delegate types we are working with are void with no arguments, they can just be invoked by using the DynamicInvoke method that lives on the delegate class. Again, the beauty of the command pattern allows this command to be queued up with all the information that it needs, and then it can simply perform it when it is told to run.  
Of course, the build_command_chain ends with this line:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: blue">return</span> actions.as_command_chain(); </div>  
  
All that this method does is return a Composite of commands that when told to run, will run each of the commands that it is composed with (we’ll dive into that at a later date). So back up in the run_action method:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px">build_command_chain<DelegateType>().run(); </div>  
  
It should now be clear to see that the run() method is invoked on the Composite, that will cause all of the commands to run in sequence. In the case of run_action<context> it will cause a Composite command to be built that is composed of commands to run “context” delegates from the Grandparent down to the actual Concern itself.   
For clarification, look again at how the run_action method is used:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"> <span style="color: blue">void</span> prepare_to_make_an_observation()    <p style="margin: 0px"> {    <p style="margin: 0px"> run_action<<span style="color: #2b91af">context</span>>();    <p style="margin: 0px"> initialize_the_sut();    <p style="margin: 0px"> run_action<<span style="color: #2b91af">after_the_sut_has_been_initialized</span>>();    <p style="margin: 0px"> run_action<<span style="color: #2b91af">because</span>>();    <p style="margin: 0px"> } </div>  
The other calls to run action simply walk down the hierarchy invoking the appropriate delegate fields that may or may not be present in the actual test classes. The because block is the behaviour we are invoking of our system under test. In the case of the test we first examined:  <div style="font-size: 12pt; background: white; overflow: auto; color: black; font-family: verdana">   <p style="margin: 0px"><span style="color: #2b91af">because</span> b = () => sut.map(item, destination); </div>  
For the design pattern aware, you will have already realized that the prepare_to_make_an_observation method (along with the use of delegate fields that can be defined at any level of the hierarchy) is just a specialization of the template method pattern, the main difference being that subclasses do not provide their behaviour by overriding abstract methods, rather they just simply have to define fields of a certain delegate type, that contain the code that will be invoked dynamically by the base class using reflection!!  
That is enough for now, we’ll carry on the drilldown in the next part!!  
Develop With Passion!!




