---
layout: post
title: "Test examples with MBUnit and jpboodhoo.bdd"
comments: true
date: 2009-01-27 09:00
categories:
- c sharp
- programming
---

The other day I placed a library up on assembla that I use as a place to store my current set of conventions on writing unit tests. My current flavour of testing focuses on the use of BDD to emphasize context and behaviour of a particular SUT (System under test) that I am exercising.  
This post is not about detailing my current thinking on BDD, more to demonstrate some ways that you can use the very small framework in conjunction with MBUnit to remove a lot of cruft from your tests. To that end, the following are some sample tests written to demonstrate different aspects of the library:  
1) Adding two numbers (without a because block):  
  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">class</span> <span style="color: yellow">when_adding_2_numbers_together</span> : <span style="color: yellow">observations_for_a_static_sut</span>    <p style="margin: 0px"> {    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_result_in_the_sum_of_the_2_numbers()    <p style="margin: 0px"> {    <p style="margin: 0px"> (2 + 2).should_be_equal_to(4);    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
  
Notice that the class simply inherits from a class named observations_for_a_static_sut. This is the base class you will use when you are either testing a static class, or (as in this case) you are simply writing a quick inline test.  
2) Adding two numbers with a because block (the because block is meant to focus your eyes to the actual behaviour you are exercising:  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">class</span> <span style="color: yellow">when_adding_2_numbers_together</span> : <span style="color: yellow">observations_for_a_static_sut</span>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #ff8000">int</span> result;    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">because</span> b = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> result = 2 + 2;    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_result_in_the_sum_of_the_2_numbers()    <p style="margin: 0px"> {    <p style="margin: 0px"> result.should_be_equal_to(4);    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
The behaviour being exercises is placed inside of a anonymous method block assigned to a delegate type (because). It is also important to note that the field is static.  
Let’s look at a slightly more involved test that has some dependencies, a factory method for the system under test, etc. Here is the start:  
  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> [<span style="color: yellow">Concern</span>(<span style="color: #ff8000">typeof</span> (<span style="color: yellow">DatabaseGateway</span>))]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">class</span> <span style="color: yellow">when_retrieving_a_set_of_rows_based_on_a_query</span> : <span style="color: yellow">observations_for_a_sut_without_a_contract</span><<span style="color: yellow">DatabaseGateway</span>>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IEnumerable</span><<span style="color: yellow">DataRow</span>> result;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IQuery</span> query;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDatabaseConnectionFactory</span> connection_factory;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDatabaseConnection</span> connection;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDbCommand</span> command;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDataReader</span> reader;    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">context</span> c = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> connection_factory = an<<span style="color: #2b91af">IDatabaseConnectionFactory</span>>();    <p style="margin: 0px"> query = an<<span style="color: #2b91af">IQuery</span>>();    <p style="margin: 0px"> connection = an<<span style="color: #2b91af">IDatabaseConnection</span>>();    <p style="margin: 0px"> command = an<<span style="color: #2b91af">IDbCommand</span>>();    <p style="margin: 0px"> reader = an<<span style="color: #2b91af">IDataReader</span>>();    <p style="margin: 0px">    <p style="margin: 0px"> connection_factory.Stub(x => x.create()).Return(connection);    <p style="margin: 0px"> connection.Stub(x => x.create_to_run(query)).Return(command);    <p style="margin: 0px"> command.Stub(x => x.ExecuteReader()).Return(reader);    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">because</span> b = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> result = sut.get_rows_matching(query);    <p style="margin: 0px"> result.force_traversal();    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_leverage_db_infrastructure_to_return_a_set_of_rows_from_the_db()    <p style="margin: 0px"> {    <p style="margin: 0px"> result.should_not_be_null();    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_dispose_the_appropriate_items()    <p style="margin: 0px"> {    <p style="margin: 0px"> connection.was_told_to(x => x.Dispose());    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">override</span> <span style="color: yellow">DatabaseGateway</span> create_sut()    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">return</span> <span style="color: #ff8000">new</span> <span style="color: yellow">DatabaseGateway</span>(connection_factory);    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
Let’s start by taking a look at the context block:  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> <span style="color: #2b91af">context</span> c = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> connection_factory = an<<span style="color: #2b91af">IDatabaseConnectionFactory</span>>();    <p style="margin: 0px"> query = an<<span style="color: #2b91af">IQuery</span>>();    <p style="margin: 0px"> connection = an<<span style="color: #2b91af">IDatabaseConnection</span>>();    <p style="margin: 0px"> command = an<<span style="color: #2b91af">IDbCommand</span>>();    <p style="margin: 0px"> reader = an<<span style="color: #2b91af">IDataReader</span>>();    <p style="margin: 0px">    <p style="margin: 0px"> connection_factory.Stub(x => x.create()).Return(connection);    <p style="margin: 0px"> connection.Stub(x => x.create_to_run(query)).Return(command);    <p style="margin: 0px"> command.Stub(x => x.ExecuteReader()).Return(reader);    <p style="margin: 0px"> }; </div>  
  
In this block I define all of the dependencies that are going to come into play during the test. The “an” method, is a generic method that lives on the base class, which basically creates a mock of the contract in question. It carries on to setup return values for method calls that will be leveraged during the course of the SUT doing its work. Unfortunately, it is hard to identify which mocks are direct dependencies of the sut and which are collaborators. It is only when you look at the factory method for the system under test:  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">override</span> <span style="color: yellow">DatabaseGateway</span> create_sut()    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">return</span> <span style="color: #ff8000">new</span> <span style="color: yellow">DatabaseGateway</span>(connection_factory);    <p style="margin: 0px"> } </div>  
  
Here it is evident that the direct dependency of the DatabaseGateway is the connection_factory (IDatabaseConnectionFactory). The because block highlights the behaviour being tested:  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> <span style="color: #2b91af">because</span> b = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> result = sut.get_rows_matching(query);    <p style="margin: 0px"> result.force_traversal();    <p style="margin: 0px"> }; </div>  
The force_traversal method is a utility method that forces the traversal of an enumerable. It is necessary as the implementation of the method under test uses deferred execution by nature of leveraging the yield keyword and returning an IEnumerable. Here is the implementation of the class under test:  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">class</span> <span style="color: yellow">DatabaseGateway</span>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #2b91af">IDatabaseConnectionFactory</span> connection_factory;    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #ff8000">public</span> DatabaseGateway(<span style="color: #2b91af">IDatabaseConnectionFactory</span> connection_factory)    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">this</span>.connection_factory = connection_factory;    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #2b91af">IEnumerable</span><<span style="color: yellow">DataRow</span>> get_rows_matching(<span style="color: #2b91af">IQuery</span> query)    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">var</span> table = <span style="color: #ff8000">new</span> <span style="color: yellow">DataTable</span>();    <p style="margin: 0px"> <span style="color: #ff8000">using</span> (<span style="color: #ff8000">var</span> connection = connection_factory.create())    <p style="margin: 0px"> <span style="color: #ff8000">using</span> (<span style="color: #ff8000">var</span> command = connection.create_to_run(query))    <p style="margin: 0px"> <span style="color: #ff8000">using</span> (<span style="color: #ff8000">var</span> reader = command.ExecuteReader())    <p style="margin: 0px"> {    <p style="margin: 0px"> table.Load(reader);    <p style="margin: 0px"> }    <p style="margin: 0px"> <span style="color: #ff8000">foreach</span> (<span style="color: yellow">DataRow</span> row <span style="color: #ff8000">in</span> table.Rows) <span style="color: #ff8000">yield</span> <span style="color: #ff8000">return</span> row;    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
Let’s now show the exact same test written with the minimum amount of plumbing code that is necessary:  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> [<span style="color: yellow">Concern</span>(<span style="color: #ff8000">typeof</span> (<span style="color: yellow">DatabaseGateway</span>))]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">class</span> <span style="color: yellow">when_retrieving_a_set_of_rows_based_on_a_query</span> : <span style="color: yellow">observations_for_a_sut_without_a_contract</span><<span style="color: yellow">DatabaseGateway</span>>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IEnumerable</span><<span style="color: yellow">DataRow</span>> result;    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">context</span> c = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> the_dependency<<span style="color: #2b91af">IDatabaseConnectionFactory</span>>().Stub(x => x.create()).Return(the_dependency<<span style="color: #2b91af">IDatabaseConnection</span>>());    <p style="margin: 0px"> the_dependency<<span style="color: #2b91af">IDatabaseConnection</span>>().Stub(x => x.create_to_run(the_dependency<<span style="color: #2b91af">IQuery</span>>())).Return(the_dependency<<span style="color: #2b91af">IDbCommand</span>>());    <p style="margin: 0px"> the_dependency<<span style="color: #2b91af">IDbCommand</span>>().Stub(x => x.ExecuteReader()).Return(the_dependency<<span style="color: #2b91af">IDataReader</span>>());    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">because</span> b = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> result = sut.get_rows_matching(the_dependency<<span style="color: #2b91af">IQuery</span>>());    <p style="margin: 0px"> result.force_traversal();    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_leverage_db_infrastructure_to_return_a_set_of_rows_from_the_db()    <p style="margin: 0px"> {    <p style="margin: 0px"> result.should_not_be_null();    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_dispose_the_appropriate_items()    <p style="margin: 0px"> {    <p style="margin: 0px"> the_dependency<<span style="color: #2b91af">IDatabaseConnection</span>>().was_told_to(x => x.Dispose());    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
  
The factory method has been removed along with the fields to reference the dependencies that come into play. For readability, I think this approach loses out, so this last way is the way I would finish up with:  <div style="font-size: 14pt; background: black; color: white; font-family: consolas">   <p style="margin: 0px"> [<span style="color: yellow">Concern</span>(<span style="color: #ff8000">typeof</span> (<span style="color: yellow">DatabaseGateway</span>))]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">class</span> <span style="color: yellow">when_retrieving_a_set_of_rows_based_on_a_query</span> : <span style="color: yellow">observations_for_a_sut_without_a_contract</span><<span style="color: yellow">DatabaseGateway</span>>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IEnumerable</span><<span style="color: yellow">DataRow</span>> result;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IQuery</span> query;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDatabaseConnectionFactory</span> connection_factory;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDatabaseConnection</span> connection;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDbCommand</span> command;    <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #2b91af">IDataReader</span> reader;    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">context</span> c = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> connection_factory = the_dependency<<span style="color: #2b91af">IDatabaseConnectionFactory</span>>();    <p style="margin: 0px"> query = an<<span style="color: #2b91af">IQuery</span>>();    <p style="margin: 0px"> connection = an<<span style="color: #2b91af">IDatabaseConnection</span>>();    <p style="margin: 0px"> command = an<<span style="color: #2b91af">IDbCommand</span>>();    <p style="margin: 0px"> reader = an<<span style="color: #2b91af">IDataReader</span>>();    <p style="margin: 0px">    <p style="margin: 0px"> connection_factory.Stub(x => x.create()).Return(connection);    <p style="margin: 0px"> connection.Stub(x => x.create_to_run(query)).Return(command);    <p style="margin: 0px"> command.Stub(x => x.ExecuteReader()).Return(reader);    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #2b91af">because</span> b = () =>    <p style="margin: 0px"> {    <p style="margin: 0px"> result = sut.get_rows_matching(query);    <p style="margin: 0px"> result.force_traversal();    <p style="margin: 0px"> };    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_leverage_db_infrastructure_to_return_a_set_of_rows_from_the_db()    <p style="margin: 0px"> {    <p style="margin: 0px"> result.should_not_be_null();    <p style="margin: 0px"> }    <p style="margin: 0px">    <p style="margin: 0px"> [<span style="color: yellow">Observation</span>]    <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">void</span> should_dispose_the_appropriate_items()    <p style="margin: 0px"> {    <p style="margin: 0px"> connection.was_told_to(x => x.Dispose());    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
This tests reintroduces the fields to store the mocks. It still removes the factory method, and it uses the following two different methods:  <ul>   <li>the_dependency<T></li>    <li>an<T></li> </ul>  
to differentiate between a constructor depedency and a mock that happens to come into play while collaborating with that dependency.  
There are lots of other things you can do, and I will post more examples as requests come in!!  
  
Develop With Passion!!




