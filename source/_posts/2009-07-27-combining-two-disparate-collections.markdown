---
layout: post
title: "Combining two disparate collections"
comments: true
date: 2009-07-27 09:00
categories:
- c sharp
- programming
---

During class last week someone had written a piece of code right near the end of the last evening and I committed to showing them a potential refactoring that could be used. Here is the piece of code in question:   
  <div style="font-family: consolas; background: black; color: white; font-size: 14pt">   <p style="margin: 0px"> <span style="color: #ff8000">var</span> info_list = <span style="color: #ff8000">new</span> <span style="color: yellow">List</span><<span style="color: yellow">ResolverConfigurationInfo</span>>(parser());    <p style="margin: 0px"> <span style="color: #ff8000">var</span> resolver_items = info_list.Select(x => factory(x)).ToList();    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #ff8000">var</span> index = 0;    <p style="margin: 0px"> parser().each(item =>    <p style="margin: 0px"> {    <p style="margin: 0px"> resolvers.Add(item.AbstractType, resolver_items[index]);    <p style="margin: 0px"> index++;    <p style="margin: 0px"> }); </div>  
The code is not really complicated. The messiness comes from the fact that an index needs to be maintained so that it can be used to lookup into another equally sized collection that is not the target of the iteration. There are obviously lots of ways to solve this, but I thought "why not just flatten the two collections into a single collection which eliminates the need for the index. Here is the resulting code that was produced:   
  <div style="font-family: consolas; background: black; color: white; font-size: 14pt">   <p style="margin: 0px"> <span style="color: #ff8000">var</span> info_list = <span style="color: #ff8000">new</span> <span style="color: yellow">List</span><<span style="color: yellow">ResolverConfigurationInfo</span>>(parser());    <p style="margin: 0px"> <span style="color: #ff8000">var</span> resolver_items = info_list.Select(x => factory(x)).ToList();    <p style="margin: 0px"> info_list.union(resolver_items).each(item => resolvers.Add(item.first_value.AbstractType, item.second_value)); </div>  
The union method is a new extension method that will take 2 disparate collections of the same size and combine them into a singular collection of Tuple<T,U> types. I created a simple Tuple class as nothing more than as an immutable parameter object. Here is the resulting code for it (very simple):   
  <div style="font-family: consolas; background: black; color: white; font-size: 14pt">   <p style="margin: 0px"> <span style="color: #ff8000">public</span> <span style="color: #ff8000">class</span> <span style="color: yellow">Tuple</span><FirstType, SecondType>    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">public</span> FirstType first_value { <span style="color: #ff8000">get</span>; <span style="color: #ff8000">private</span> <span style="color: #ff8000">set</span>; }    <p style="margin: 0px"> <span style="color: #ff8000">public</span> SecondType second_value { <span style="color: #ff8000">get</span>; <span style="color: #ff8000">private</span> <span style="color: #ff8000">set</span>; }    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #ff8000">public</span> Tuple(FirstType first, SecondType second_type)    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: #ff8000">this</span>.first_value = first;    <p style="margin: 0px"> <span style="color: #ff8000">this</span>.second_value = second_type;    <p style="margin: 0px"> }    <p style="margin: 0px"> } </div>  
Finally the code that pulls it all together is here in the extension method that does the heavy lifting:   
  <div style="font-family: consolas; background: black; color: white; font-size: 14pt">   <p style="margin: 0px"> <span style="color: #ff8000">static</span> <span style="color: #ff8000">public</span> <span style="color: #2b91af">IEnumerable</span><<span style="color: yellow">Tuple</span><FirstType, SecondType>> union<FirstType, SecondType>(<span style="color: #ff8000">this</span> <span style="color: #2b91af">IEnumerable</span><FirstType> first_set,    <p style="margin: 0px"> <span style="color: #2b91af">IEnumerable</span><SecondType> second_set)    <p style="margin: 0px"> {    <p style="margin: 0px"> <span style="color: yellow">Check</span>.not_null(first_set,second_set);    <p style="margin: 0px"> <span style="color: #ff8000">var</span> first_list = first_set.ToList();    <p style="margin: 0px"> <span style="color: #ff8000">var</span> second_list = second_set.ToList();    <p style="margin: 0px"> <span style="color: yellow">Check</span>.ensure(first_list.Count == second_list.Count);    <p style="margin: 0px">    <p style="margin: 0px"> <span style="color: #ff8000">for</span> (<span style="color: #ff8000">var</span> index = 0; index < first_list.Count; index++) <span style="color: #ff8000">yield</span> <span style="color: #ff8000">return</span> <span style="color: #ff8000">new</span> <span style="color: yellow">Tuple</span><FirstType, SecondType>(first_list[index], second_list[index]);    <p style="margin: 0px"> } </div>  
This method hides the details of the indexer into a utility method that can be used anywhere where 2 sets of disparate items of the same length need to be combined into a singular set.  
Thoughts?   
Develop With Passion!!




